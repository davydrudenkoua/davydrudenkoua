"use strict";(self.webpackChunkdavydrudenko_writing=self.webpackChunkdavydrudenko_writing||[]).push([[981],{3403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"aks/aks-workload-identity","title":"Using Workload Identities in Azure Kubernetes Service","description":"Introduction","source":"@site/docs/aks/aks-workload-identity.md","sourceDirName":"aks","slug":"/aks/aks-workload-identity","permalink":"/davydrudenkoua/docs/aks/aks-workload-identity","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kubernetes","permalink":"/davydrudenkoua/docs/category/kubernetes"}}');var a=t(4848),i=t(8453);const s={},o="Using Workload Identities in Azure Kubernetes Service",c={},d=[{value:"Introduction",id:"introduction",level:3},{value:"What is a Workload Identity?",id:"what-is-a-workload-identity",level:4},{value:"Managed Identities in Azure",id:"managed-identities-in-azure",level:4},{value:"How it works?",id:"how-it-works",level:4},{value:"Setting up you AKS cluster to use Workload Identities",id:"setting-up-you-aks-cluster-to-use-workload-identities",level:3},{value:"Prerequisites",id:"prerequisites",level:4},{value:"Declaring necessary variables",id:"declaring-necessary-variables",level:4},{value:"Creating User-assigned Managed Identity",id:"creating-user-assigned-managed-identity",level:4},{value:"Creating &quot;Storage Blob Data Contributor&quot; Role Assignment",id:"creating-storage-blob-data-contributor-role-assignment",level:4},{value:"Creating AKS with Workload Identity and OIDC Issuer support",id:"creating-aks-with-workload-identity-and-oidc-issuer-support",level:4},{value:"Creating Kubernetes secret to pull image from Docker Hub",id:"creating-kubernetes-secret-to-pull-image-from-docker-hub",level:4},{value:"Creating Kubernetes Service Account",id:"creating-kubernetes-service-account",level:4},{value:"Creating Federated Credential",id:"creating-federated-credential",level:4},{value:"Creating API Deployment",id:"creating-api-deployment",level:4}];function l(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"using-workload-identities-in-azure-kubernetes-service",children:"Using Workload Identities in Azure Kubernetes Service"})}),"\n",(0,a.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.h4,{id:"what-is-a-workload-identity",children:"What is a Workload Identity?"}),"\n",(0,a.jsx)(n.p,{children:"Microsoft Entra Workload Identity is a technology that allows AKS pods to use Azure Identity for authorization against other Azure resources. Using it greatly improves security as it enables your applications to use Azure RBAC instead of connection strings. This allows for more fine-grained control and reduces the number of credentials you need to store securely and reliably."}),"\n",(0,a.jsx)(n.h4,{id:"managed-identities-in-azure",children:"Managed Identities in Azure"}),"\n",(0,a.jsx)(n.p,{children:"Managed Identity is a resource in Azure  that provides an identity for your applications to use for connecting to other services without the need to handle any secrets, connection strings or certificates yourself. You can use them to authenticate to any resource or application that support MS Entra authentication, including your own applications. There are System and User-assigned Managed Identities. System-assigned Managed Identities provide less granular access control -- for example, if your AKS runs more than one pod, you can't give them different permissions. User-assigned Managed Identities allow for far more granular control because you can have a separate identity for every pod with exact permissions it needs."}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Property"}),(0,a.jsx)(n.th,{children:"User-assigned managed identity"}),(0,a.jsx)(n.th,{children:"System-assigned managed identity"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Lifecycle"})}),(0,a.jsx)(n.td,{children:"Independent lifecycle"}),(0,a.jsx)(n.td,{children:"Same as the resource it was created for"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Identity Scope"})}),(0,a.jsx)(n.td,{children:"Defined by the user"}),(0,a.jsx)(n.td,{children:"Single Azure resource"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Reusability"})}),(0,a.jsx)(n.td,{children:"Can be used by multiple services"}),(0,a.jsx)(n.td,{children:"Limited to one resource"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Setup complexity"})}),(0,a.jsx)(n.td,{children:"Low"}),(0,a.jsx)(n.td,{children:"Moderate"})]})]})]}),"\n",(0,a.jsx)(n.h4,{id:"how-it-works",children:"How it works?"}),"\n",(0,a.jsxs)(n.p,{children:["Workload Identity maps Kubernetes Service Account to a User-assigned Managed Identity in Azure and closely integrates with RBAC. You simply create Role Assignments for your identity in Azure and your application uses them to access other resources. This setup allows Kubernetes pods to have specific permissions in Azure without the need to directly manage any credentials.\nPods use their Kubernetes service accounts to request access tokens using OIDC federation. Pod's service account token is used to authenticate with Azure AD. Azure AD validates the OIDC token and issues an access token for the managed identity associated with the service account, granting access to Azure resources.\n",(0,a.jsx)(n.img,{src:t(656).A+"",width:"3075",height:"2213"})]}),"\n",(0,a.jsx)(n.h3,{id:"setting-up-you-aks-cluster-to-use-workload-identities",children:"Setting up you AKS cluster to use Workload Identities"}),"\n",(0,a.jsxs)(n.p,{children:["In this tutorial we will setup a new AKS cluster for use with Workload Identities. It will have one pod running a simple Python FastAPI server deployed from a private Docker Hub registry that will create signed URLs to access files in Blob Storage. For this it will need ",(0,a.jsx)(n.code,{children:"Blob Storage Contributor"})," role in that storage account. You can find all source code in my ",(0,a.jsx)(n.a,{href:"https://github.com/davydrudenkoua/k8s-workload-identity",children:"GitHub repository"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Azure Subscription"}),"\n",(0,a.jsx)(n.li,{children:"Storage Account"}),"\n",(0,a.jsx)(n.li,{children:"Azure CLI >= 2.47.0"}),"\n",(0,a.jsx)(n.li,{children:"aks-preview Azure CLI extension >= 9.0.0b7"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"declaring-necessary-variables",children:"Declaring necessary variables"}),"\n",(0,a.jsx)(n.p,{children:"Firstly, we need to declare variables with names and location for the resources we are going to create:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'\xa0 \xa0 $ResourceGroup = "k8s-to-blobstorage"\n\xa0 \xa0 $Location = "polandcentral"\n\xa0 \xa0 $ClusterName = "cats-api-k8s"\n\xa0 \xa0 $ServiceAccountNamespace = "default"\n\xa0 \xa0 $ServiceAccountName="cats-api-sa"\n\xa0 \xa0 $SubscriptionId = $(az account show --query "id" --output tsv)\n\xa0 \xa0 $UserAssignedIdentityName="CatsApiUserAssignedIdentity"\n\xa0 \xa0 $FederatedIdentityCredentialName="CatsApiFederatedIdentity"\n'})}),"\n",(0,a.jsx)(n.h4,{id:"creating-user-assigned-managed-identity",children:"Creating User-assigned Managed Identity"}),"\n",(0,a.jsx)(n.p,{children:"This is the identity our application will use to access Azure Storage Account."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:"\xa0 \xa0 az identity create `\n\xa0 \xa0 \xa0 \xa0 --name $UserAssignedIdentityName `\n\xa0 \xa0 \xa0 \xa0 --resource-group $ResourceGroup `\n\xa0 \xa0 \xa0 \xa0 --location $Location `\n\xa0 \xa0 \xa0 \xa0 --subscription $SubscriptionId\n"})}),"\n",(0,a.jsx)(n.h4,{id:"creating-storage-blob-data-contributor-role-assignment",children:'Creating "Storage Blob Data Contributor" Role Assignment'}),"\n",(0,a.jsx)(n.p,{children:"Because our application can upload blobs and generate SAS tokens for them, we need to setup access to Storage Account."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'# Getting User-assigned Managed Identity Id\n\xa0 \xa0 $IdentityPrincipalId = $(\n\xa0 \xa0 \xa0 \xa0 az identity show `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --name $UserAssignedIdentityName `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --resource-group $ResourceGroup `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --query "principalId" `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --output tsv\n\xa0 \xa0 )\n\n# Locating Storage Account Id\n\xa0 \xa0 $StorageAccountId = $(\n\xa0 \xa0 \xa0 \xa0 az storage account show `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --resource-group $ResourceGroup `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --name "davydscats" `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --query "id" `\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 --output tsv\n\xa0 \xa0 )\n# Creating Azure Role Assignment\n\xa0 \xa0 az role assignment create `\n\xa0 \xa0 \xa0 \xa0 --assignee-object-id $IdentityPrincipalId `\n\xa0 \xa0 \xa0 \xa0 --role "Storage Blob Data Contributor" `\n\xa0 \xa0 \xa0 \xa0 --scope $StorageAccountId `\n\xa0 \xa0 \xa0 \xa0 --assignee-principal-type "ServicePrincipal"\n'})}),"\n",(0,a.jsx)(n.h4,{id:"creating-aks-with-workload-identity-and-oidc-issuer-support",children:"Creating AKS with Workload Identity and OIDC Issuer support"}),"\n",(0,a.jsx)(n.p,{children:"Create AKS cluster with the necessary features enabled using this command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'# Creating AKS Cluster with one VM\n\xa0 \xa0 az aks create `\n\xa0 \xa0 \xa0 \xa0 --resource-group $ResourceGroup `\n\xa0 \xa0 \xa0 \xa0 --name $ClusterName `\n\xa0 \xa0 \xa0 \xa0 --enable-oidc-issuer `\n\xa0 \xa0 \xa0 \xa0 --enable-workload-identity `\n\xa0 \xa0 \xa0 \xa0 --generate-ssh-keys `\n\xa0 \xa0 \xa0 \xa0 --location $Location `\n\xa0 \xa0 \xa0 \xa0 --node-vm-size "Standard_B2s" `\n\xa0 \xa0 \xa0 \xa0 --node-count 1 `\n\xa0 \xa0 \xa0 \xa0 --tier "free" `\n\xa0 \xa0 \xa0 \xa0 --load-balancer-sku basic\n# Logging in to the new cluster\t\n\xa0 \xa0 az aks get-credentials --name $ClusterName --resource-group $ResourceGroup\n\xa0 \xa0 \xa0 \xa0 \n'})}),"\n",(0,a.jsx)(n.p,{children:"\u2139\ufe0f If you do not have aks-preview or it is and older version, you might get an error similar to this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"cli.azure.cli.core.azclierror: unrecognized arguments: --tier standard\naz_command_data_logger: unrecognized arguments: --tier standard\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To check your aks-preview extension version, you can run  ",(0,a.jsx)(n.code,{children:"az extension show --name aks-preview --query version"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"creating-kubernetes-secret-to-pull-image-from-docker-hub",children:"Creating Kubernetes secret to pull image from Docker Hub"}),"\n",(0,a.jsxs)(n.p,{children:["Because the image is hosted privately, you will need to create a Kubernetes secret for it to be able to pull it when creating a deployment. I'm using environment variables not to put sensitive data in the script, but in production you can keep those values in KeyVault and access it from CI/CD environment. You can find information on how to create Docker PAT on ",(0,a.jsx)(n.a,{href:"https://docs.docker.com/security/for-developers/access-tokens/",children:"this page"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:"\xa0 \xa0 kubectl create secret docker-registry cats-api-registry-secret `\n\xa0 \xa0 \xa0 \xa0 --docker-server=https://index.docker.io/v1/ `\n\xa0 \xa0 \xa0 \xa0 --docker-username=$Env:DOCKER_USERNAME `\n\xa0 \xa0 \xa0 \xa0 --docker-password=$Env:DOCKER_PASSWORD\n"})}),"\n",(0,a.jsx)(n.h4,{id:"creating-kubernetes-service-account",children:"Creating Kubernetes Service Account"}),"\n",(0,a.jsxs)(n.p,{children:["For our pod to be able to use Workload Identity, we need to create a Kubernetes Service Account for it. To do this, create a new file named ",(0,a.jsx)(n.code,{children:"cats-api.serviceAccount.yaml"})," and add the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n\xa0 annotations:\n\xa0 \xa0 azure.workload.identity/client-id: {{USER_ASSIGNED_CLIENT_ID}}\n\xa0 name: {{SERVICE_ACCOUNT_NAME}}\n\xa0 namespace: {{SERVICE_ACCOUNT_NAMESPACE}}\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can ignore the variables in double curly brackets and just type values in. These will be replaced by actual values from PowerShell variables later.\nYou apply the template using this command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'\xa0 \xa0 $ServiceAccountTemplate = Get-Content -Path "cats-api.serviceAccount.yaml" -Raw\n\xa0 \xa0 $ServiceAccountTemplate = $ServiceAccountTemplate -replace "{{USER_ASSIGNED_CLIENT_ID}}", $UserAssignedClientId\n\xa0 \xa0 $ServiceAccountTemplate = $ServiceAccountTemplate -replace "{{SERVICE_ACCOUNT_NAME}}", $ServiceAccountName\n\xa0 \xa0 $ServiceAccountTemplate = $ServiceAccountTemplate -replace "{{SERVICE_ACCOUNT_NAMESPACE}}", $ServiceAccountNamespace\n\xa0 \xa0 Write-Host "Service account template to be applied:`n$ServiceAccountTemplate"\n\xa0 \xa0 $ServiceAccountTemplate | kubectl apply -f -\n'})}),"\n",(0,a.jsx)(n.h4,{id:"creating-federated-credential",children:"Creating Federated Credential"}),"\n",(0,a.jsxs)(n.p,{children:["For the mapping between Kubernetes Service Account and Managed Identity to work you need to create a Federated Identity Credential. You can find more information on Federated Credentials ",(0,a.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/graph/api/resources/federatedidentitycredentials-overview?view=graph-rest-1.0",children:"here"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'az identity federated-credential create `\n\xa0 \xa0 \xa0 \xa0 --name $FederatedIdentityCredentialName `\n\xa0 \xa0 \xa0 \xa0 --identity-name $UserAssignedIdentityName `\n\xa0 \xa0 \xa0 \xa0 --resource-group $ResourceGroup `\n\xa0 \xa0 \xa0 \xa0 --issuer $AksOidcIssuer `\n\xa0 \xa0 \xa0 \xa0 --subject "system:serviceaccount:${ServiceAccountNamespace}:${ServiceAccountName}" `\n\xa0 \xa0 \xa0 \xa0 --audience "api://AzureADTokenExchange"\n'})}),"\n",(0,a.jsx)(n.h4,{id:"creating-api-deployment",children:"Creating API Deployment"}),"\n",(0,a.jsxs)(n.p,{children:["Finally, we can create a Deployment and a Service for our API. Service is required for our API to be accessible from the public Internet because AKS cluster does not have a public IP by default.\nCreate new file ",(0,a.jsx)(n.code,{children:"cats-api.deployment.yaml"})," and add the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n\xa0 name: cats-api-deployment\n\xa0 labels:\n\xa0 \xa0 app: cats-api\nspec:\n\xa0 replicas: 1\n\xa0 selector:\n\xa0 \xa0 matchLabels:\n\xa0 \xa0 \xa0 app: cats-api\n\xa0 template:\n\xa0 \xa0 metadata:\n\xa0 \xa0 \xa0 labels:\n\xa0 \xa0 \xa0 \xa0 app: \xa0cats-api\n\xa0 \xa0 \xa0 \xa0 azure.workload.identity/use: "true"\n\xa0 \xa0 spec:\n\xa0 \xa0 \xa0 serviceAccountName: {{SERVICE_ACCOUNT_NAME}}\n\xa0 \xa0 \xa0 containers:\n\xa0 \xa0 \xa0 - name: \xa0cats-api\n\xa0 \xa0 \xa0 \xa0 image: \xa0davydrudenkoua/cats-api:latest\n\xa0 \xa0 \xa0 \xa0 resources:\n\xa0 \xa0 \xa0 \xa0 \xa0 requests:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cpu: 100m\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 memory: 100Mi\n\xa0 \xa0 \xa0 \xa0 \xa0 limits:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 cpu: 100m\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 memory: 100Mi\n\xa0 \xa0 \xa0 imagePullSecrets:\n\xa0 \xa0 \xa0 \xa0 - name: cats-api-registry-secret\n---\napiVersion: v1\nkind: Service\nmetadata:\n\xa0 name: cats-api-loadbalancer\n\xa0 labels:\n\xa0 \xa0 app: cats-api\nspec:\n\xa0 selector:\n\xa0 \xa0 app: cats-api\n\xa0 type: LoadBalancer\n\xa0 ports:\n\xa0 - name: cats-api\n\xa0 \xa0 protocol: TCP\n\xa0 \xa0 port: 8080\n\xa0 \xa0 targetPort: 80\n'})}),"\n",(0,a.jsx)(n.p,{children:"To apply it, run"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-powershell",children:'$DeploymentTemplate = Get-Content -Path "cats-api.deployment.yaml" -Raw\n$DeploymentTemplate = $DeploymentTemplate -replace "{{SERVICE_ACCOUNT_NAME}}", $ServiceAccountName\n$DeploymentTemplate | kubectl apply -f -\n'})}),"\n",(0,a.jsxs)(n.p,{children:["\u2139\ufe0f You probably won't have access to this Docker image as it is published in a private registry. To run your own image, replace ",(0,a.jsx)(n.code,{children:"spec.template.spec.containers.image"})," with your image and create secret accordingly.\nThat's it, your API should be up and able to access files in your Storage Account!"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},656:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/aks-wi-overview-d5d35818f23958eddd0c2e634b59f8dd.png"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);